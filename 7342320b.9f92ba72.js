(window.webpackJsonp=window.webpackJsonp||[]).push([[160],{261:function(e,r,t){"use strict";t.r(r),t.d(r,"frontMatter",(function(){return c})),t.d(r,"metadata",(function(){return o})),t.d(r,"rightToc",(function(){return i})),t.d(r,"default",(function(){return s}));var n=t(2),a=t(6),l=(t(0),t(428)),c={title:"Parser"},o={id:"version-0.3.1/api/Parser",isDocsHomePage:!1,title:"Parser",description:"recurse",source:"@site/versioned_docs/version-0.3.1/api/Parser.md",permalink:"/docs/0.3.1/api/Parser",editUrl:"https://github.com/parsica-php/parsica/tree/main/versioned_docs/version-0.3.1/api/Parser.md",version:"0.3.1",sidebar:"version-0.3.1/docs",previous:{title:"ParseResult",permalink:"/docs/0.3.1/api/ParseResult"},next:{title:"ParserFailure",permalink:"/docs/0.3.1/api/ParserFailure"},latestVersionMainDocPermalink:"/docs"},i=[{value:"recurse",id:"recurse",children:[]},{value:"run",id:"run",children:[]},{value:"optional",id:"optional",children:[]},{value:"or",id:"or",children:[]},{value:"followedBy",id:"followedby",children:[]},{value:"sequence",id:"sequence",children:[]},{value:"label",id:"label",children:[]},{value:"bind",id:"bind",children:[]},{value:"map",id:"map",children:[]},{value:"continueFrom",id:"continuefrom",children:[]},{value:"construct",id:"construct",children:[]},{value:"append",id:"append",children:[]},{value:"try",id:"try",children:[]},{value:"apply",id:"apply",children:[]},{value:"thenIgnore",id:"thenignore",children:[]},{value:"notFollowedBy",id:"notfollowedby",children:[]}],p={rightToc:i};function s(e){var r=e.components,t=Object(a.a)(e,["components"]);return Object(l.b)("wrapper",Object(n.a)({},p,t,{components:r,mdxType:"MDXLayout"}),Object(l.b)("h3",{id:"recurse"},"recurse"),Object(l.b)("p",null,"Recurse on a parser. Used in combination with {@see recursive()}. After calling this method, this parser behaves\nlike a regular parser."),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-php"}),"public function recurse(Parser $parser) : Parser\n")),Object(l.b)("h3",{id:"run"},"run"),Object(l.b)("p",null,"Run the parser on an input"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-php"}),"public function run(string $input) : ParseResult\n")),Object(l.b)("h3",{id:"optional"},"optional"),Object(l.b)("p",null,"Optionally parse something, but still succeed if the thing is not there."),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-php"}),"public function optional() : Parser\n")),Object(l.b)("h3",{id:"or"},"or"),Object(l.b)("p",null,"Try the first parser, and failing that, try the second parser. Returns the first succeeding result, or the first\nfailing result."),Object(l.b)("p",null,"Caveat: The order matters!\nstring('http')->or(string('https')"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-php"}),"public function or(Parser $other) : Parser\n")),Object(l.b)("h3",{id:"followedby"},"followedBy"),Object(l.b)("p",null,"Alias for ",Object(l.b)("inlineCode",{parentName:"p"},"sequence()"),". Parse something, then follow by something else. Ignore the result of the first parser and return the result of the\nsecond parser."),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-php"}),"public function followedBy(Parser $second) : Parser\n")),Object(l.b)("h3",{id:"sequence"},"sequence"),Object(l.b)("p",null,"Parse something, then follow by something else. Ignore the result of the first parser and return the result of the\nsecond parser."),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-php"}),"public function sequence(Parser $second) : Parser\n")),Object(l.b)("h3",{id:"label"},"label"),Object(l.b)("p",null,"Label a parser. When a parser fails, instead of a generated error message, you'll see your label.\neg (char(':')->followedBy(char(')')).followedBy(char(')'))."),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-php"}),"public function label(string $label) : Parser\n")),Object(l.b)("h3",{id:"bind"},"bind"),Object(l.b)("p",null,"Create a parser that takes the output from the first parser (if successful) and feeds it to the callable. The\ncallable must return another parser. If the first parser fails, the first parser is returned."),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-php"}),"public function bind(callable $f) : Parser\n")),Object(l.b)("h3",{id:"map"},"map"),Object(l.b)("p",null,"Map a function over the parser (which in turn maps it over the result)."),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-php"}),"public function map(callable $transform) : Parser\n")),Object(l.b)("h3",{id:"continuefrom"},"continueFrom"),Object(l.b)("p",null,"Take the remaining input from the result and parse it"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-php"}),"public function continueFrom(ParseResult $result) : ParseResult\n")),Object(l.b)("h3",{id:"construct"},"construct"),Object(l.b)("p",null,"Construct a class with thee parser's output as the constructor argument"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-php"}),"public function construct(string $className) : Parser\n")),Object(l.b)("h3",{id:"append"},"append"),Object(l.b)("p",null,"Combine the parser with another parser of the same type, which will cause the results to be appended."),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-php"}),"public function append(Parser $other) : Parser\n")),Object(l.b)("h3",{id:"try"},"try"),Object(l.b)("p",null,"Try to parse the input, or throw an exception;"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-php"}),"public function try(string $input) : ParseResult\n")),Object(l.b)("h3",{id:"apply"},"apply"),Object(l.b)("p",null,"Sequential application."),Object(l.b)("p",null,"The first parser must be of type Parser<callable(T2):T3>."),Object(l.b)("p",null,"apply :: f (a -> b) -> f a -> f b"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-php"}),"public function apply(Parser $parser) : Parser\n")),Object(l.b)("h3",{id:"thenignore"},"thenIgnore"),Object(l.b)("p",null,"Sequence two parsers, and return the output of the first one, ignore the second."),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-php"}),"public function thenIgnore(Parser $other) : Parser\n")),Object(l.b)("h3",{id:"notfollowedby"},"notFollowedBy"),Object(l.b)("p",null,"notFollowedBy only succeeds when $second fails. It never consumes any input."),Object(l.b)("p",null,"Example:"),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},'string("print")'),' will also match "printXYZ"'),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},'string("print")->notFollowedBy(alphaNumChar()))'),' will match "print something" but not "printXYZ something"'),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-php"}),"public function notFollowedBy(Parser $second) : Parser\n")))}s.isMDXComponent=!0},428:function(e,r,t){"use strict";t.d(r,"a",(function(){return u})),t.d(r,"b",(function(){return h}));var n=t(0),a=t.n(n);function l(e,r,t){return r in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e}function c(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);r&&(n=n.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),t.push.apply(t,n)}return t}function o(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?c(Object(t),!0).forEach((function(r){l(e,r,t[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):c(Object(t)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))}))}return e}function i(e,r){if(null==e)return{};var t,n,a=function(e,r){if(null==e)return{};var t,n,a={},l=Object.keys(e);for(n=0;n<l.length;n++)t=l[n],r.indexOf(t)>=0||(a[t]=e[t]);return a}(e,r);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)t=l[n],r.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var p=a.a.createContext({}),s=function(e){var r=a.a.useContext(p),t=r;return e&&(t="function"==typeof e?e(r):o(o({},r),e)),t},u=function(e){var r=s(e.components);return a.a.createElement(p.Provider,{value:r},e.children)},b={inlineCode:"code",wrapper:function(e){var r=e.children;return a.a.createElement(a.a.Fragment,{},r)}},d=a.a.forwardRef((function(e,r){var t=e.components,n=e.mdxType,l=e.originalType,c=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),u=s(t),d=n,h=u["".concat(c,".").concat(d)]||u[d]||b[d]||l;return t?a.a.createElement(h,o(o({ref:r},p),{},{components:t})):a.a.createElement(h,o({ref:r},p))}));function h(e,r){var t=arguments,n=r&&r.mdxType;if("string"==typeof e||n){var l=t.length,c=new Array(l);c[0]=d;var o={};for(var i in r)hasOwnProperty.call(r,i)&&(o[i]=r[i]);o.originalType=e,o.mdxType="string"==typeof e?e:n,c[1]=o;for(var p=2;p<l;p++)c[p]=t[p];return a.a.createElement.apply(null,c)}return a.a.createElement.apply(null,t)}d.displayName="MDXCreateElement"}}]);