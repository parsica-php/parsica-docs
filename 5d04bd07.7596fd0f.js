(window.webpackJsonp=window.webpackJsonp||[]).push([[94],{194:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return o})),t.d(n,"metadata",(function(){return i})),t.d(n,"rightToc",(function(){return s})),t.d(n,"default",(function(){return p}));var r=t(2),a=(t(0),t(346));const o={title:"Dealing with Space"},i={id:"tutorial/11_dealing_with_space",isDocsHomePage:!1,title:"Dealing with Space",description:"Parsica comes with a number of useful parsers for dealing with different types of whitespace and newlines, as well with required or optional whitespace. We recommend browsing src/space.php to see what is available, so you don't need to build your own parsers for that.",source:"@site/docs/tutorial/11_dealing_with_space.md",permalink:"/docs/next/tutorial/11_dealing_with_space",editUrl:"https://github.com/mathiasverraes/parsica/tree/main/docs/tutorial/11_dealing_with_space.md",version:"next",sidebar:"docs",previous:{title:"Side Effects and Events",permalink:"/docs/next/tutorial/10_side_effects"},next:{title:"Parsing Expression Languages",permalink:"/docs/next/tutorial/20_expressions"},latestVersionMainDocPermalink:"/docs"},s=[{value:"Space consumers",id:"space-consumers",children:[]}],c={rightToc:s};function p({components:e,...n}){return Object(a.b)("wrapper",Object(r.a)({},c,n,{components:e,mdxType:"MDXLayout"}),Object(a.b)("p",null,"Parsica comes with a number of useful parsers for dealing with different types of whitespace and newlines, as well with required or optional whitespace. We recommend browsing ",Object(a.b)("inlineCode",{parentName:"p"},"src/space.php")," to see what is available, so you don't need to build your own parsers for that. "),Object(a.b)("h2",{id:"space-consumers"},"Space consumers"),Object(a.b)("p",null,"When building a parser for say a language or a file format, you often have specific rules about space. Whitespace can be required or optional, and expressions can be valid or invalid if they contain newlines. All of these are could be valid or invalid depending on your case:"),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{}),"// with 0, 1, or more spaces\n1+1\n1 + 1\n1   +   1\n\n// multiline\n1 +\n2\n\n// tabs\n1 \n  + 2\n")),Object(a.b)("p",null,"There's too much variation for Parsica to provide a single solution. However, you don't want to litter your code with space parsers everywhere:"),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-php"}),"<?php\n$term = digitChar();\n$operator = char('+');\n$parser = collect(\n        $term,\n        skipSpace1(),\n        $operator,\n        skipSpace1(),\n        $term,\n        skipSpace1(),\n    )->map(fn($o) => $o[0] + $o[4]);\n\n$result = $parser->tryString(\"1  +\\n  2\\t\");\nassertSame(3, $result->output());\n")),Object(a.b)("p",null,"This is noisy. And if you want to change the rules about whitespace or build more complex parsers, you have to deal with this problem all the time, making it unmaintainable (or at least annoying)."),Object(a.b)("p",null,"The idea is to build a space consumer that you can reuse everywhere. The space consumer is a parser combinator that you wrap around another parser, and that returns the output of the inner parser, ignoring whitespace. A typical approach is to consistently ignore space after the thing you're interested in. "),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-php"}),'<?php\n// $token behaves just like $parser, but requires the parsed \n// value to be followed by at least 1 space\n$token = fn(Parser $parser) => keepFirst($parser, skipSpace1());\n\n// Now we wrap our parsers\n$term = $token(digitChar());\n$operator = $token(char(\'+\'));\n\n// Our main parser now has the same "shape" as the expression we\'re trying to parse:\n$parser = collect(\n        $term,\n        $operator,\n        $term,\n    )->map(fn($o) => $o[0] + $o[2]);\n\n$result = $parser->tryString("1  +\\n  2\\t");\nassertSame(3, $result->output());\n')),Object(a.b)("p",null,"Now, all the logic for skipping space is nicely contained in ",Object(a.b)("inlineCode",{parentName:"p"},"$token"),". If we wanted to disallow multiline expressions, we only need to replace ",Object(a.b)("inlineCode",{parentName:"p"},"skipSpace1()")," with ",Object(a.b)("inlineCode",{parentName:"p"},"skipHSpace1()")," in one place."),Object(a.b)("p",null,"As an example, here's an excerpt from the JSON parser, using the ws (whitespace) as defined in the JSON spec:"),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-php"}),"final class MyJSON\n{ \n    public static function ws(): Parser\n    {\n        return zeroOrMore(satisfy(isCharCode([0x20, 0x0A, 0x0D, 0x09])))->voidLeft(null)\n            ->label('whitespace');\n    }\n\n    public static function token(Parser $parser): Parser\n    {\n        return keepFirst($parser, JSON::ws());\n    }\n\n    public static function object(): Parser\n    {\n        return map(\n            between(\n                JSON::token(char('{')),\n                JSON::token(char('}')),\n                sepBy(\n                    JSON::token(char(',')),\n                    JSON::member()\n                )\n            ),\n            fn(array $members):object => (object)array_merge(...$members));\n    }\n\n    // see src/JSON/JSON.php for the full code\n}\n")),Object(a.b)("p",null,"If you have multiple ways of handling space in one parser, you can of course define multiple space consumers and give them relevant names."))}p.isMDXComponent=!0},346:function(e,n,t){"use strict";t.d(n,"a",(function(){return u})),t.d(n,"b",(function(){return m}));var r=t(0),a=t.n(r);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function c(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var p=a.a.createContext({}),l=function(e){var n=a.a.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},u=function(e){var n=l(e.components);return a.a.createElement(p.Provider,{value:n},e.children)},b={inlineCode:"code",wrapper:function(e){var n=e.children;return a.a.createElement(a.a.Fragment,{},n)}},d=a.a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,i=e.parentName,p=c(e,["components","mdxType","originalType","parentName"]),u=l(t),d=r,m=u["".concat(i,".").concat(d)]||u[d]||b[d]||o;return t?a.a.createElement(m,s(s({ref:n},p),{},{components:t})):a.a.createElement(m,s({ref:n},p))}));function m(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,i=new Array(o);i[0]=d;var s={};for(var c in n)hasOwnProperty.call(n,c)&&(s[c]=n[c]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var p=2;p<o;p++)i[p]=t[p];return a.a.createElement.apply(null,i)}return a.a.createElement.apply(null,t)}d.displayName="MDXCreateElement"}}]);